<!DOCTYPE html>
<html lang="en">

<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Obscura â€” Secure Message Studio</title>

    <script src="https://cdn.tailwindcss.com"></script>
    <script src="https://cdnjs.cloudflare.com/ajax/libs/gsap/3.12.5/gsap.min.js"></script>

    <style>
        body {
            transition: background 0.4s, color 0.4s
        }

        .page {
            display: none
        }

        .page.active {
            display: block
        }

        .overlay {
            position: fixed;
            inset: 0;
            background: black;
            transform: translateY(-100%);
            z-index: 100
        }

        canvas {
            display: none
        }
    </style>
</head>

<body class="bg-neutral-950 text-neutral-100 font-sans">

    <div class="overlay"></div>

    <nav class="fixed w-full backdrop-blur-md bg-opacity-60 border-b border-neutral-800 z-50">
        <div class="max-w-7xl mx-auto px-6 py-4 flex justify-between items-center">
            <div class="text-2xl font-bold">Obscura</div>
            <div class="flex gap-8 text-sm">
                <a href="#home" data-link>Home</a>
                <a href="#encrypt" data-link>Encrypt</a>
                <a href="#decrypt" data-link>Decrypt</a>
                <button id="themeToggle" class="border px-4 py-1 rounded-full text-xs">Toggle</button>
            </div>
        </div>
    </nav>

    <div class="pt-24"></div>

    <!-- HOME -->
    <section data-page="home" class="page active max-w-6xl mx-auto px-6 space-y-20 pb-32">
        <h1 class="text-6xl md:text-8xl font-bold leading-tight">
            Encrypted. Embedded. Invisible.
        </h1>
        <p class="text-xl text-neutral-400 max-w-3xl">
            AES-256 encryption + dual-mode image steganography.
            Everything runs securely in your browser.
        </p>
    </section>

    <!-- ENCRYPT -->
    <section data-page="encrypt" class="page max-w-5xl mx-auto px-6 space-y-12 pb-32">
        <h1 class="text-5xl font-bold">Encrypt & Hide</h1>

        <textarea id="message" placeholder="Enter confidential message..."
            class="w-full p-4 bg-neutral-900 border border-neutral-800 rounded-xl h-40"></textarea>

        <input type="password" id="password" placeholder="Enter secret key"
            class="w-full p-4 bg-neutral-900 border border-neutral-800 rounded-xl">

        <select id="modeSelect" class="w-full p-4 bg-neutral-900 border border-neutral-800 rounded-xl">
            <option value="stealth">Visible Encryption Mode</option>
            <option value="visible">
                Stealth Mode (Invisible)
            </option>
        </select>

        <input type="file" id="imageInput" accept="image/png"
            class="w-full p-4 bg-neutral-900 border border-neutral-800 rounded-xl">

        <button onclick="encryptAndHide()" class="px-8 py-3 bg-white text-black rounded-full font-semibold">
            Generate Secure Image
        </button>

        <div id="previewContainer" class="hidden space-y-4">
            <img id="previewImage" class="rounded-xl border border-neutral-700" />
            <a id="downloadLink" class="underline text-green-400">
                Download Encrypted Image
            </a>
        </div>
    </section>

    <!-- DECRYPT -->
    <section data-page="decrypt" class="page max-w-5xl mx-auto px-6 space-y-12 pb-32">
        <h1 class="text-5xl font-bold">Extract & Decrypt</h1>

        <input type="file" id="stegoInput" accept="image/png"
            class="w-full p-4 bg-neutral-900 border border-neutral-800 rounded-xl">

        <input type="password" id="decryptPassword" placeholder="Enter secret key"
            class="w-full p-4 bg-neutral-900 border border-neutral-800 rounded-xl">

        <button onclick="extractAndDecrypt()" class="px-8 py-3 bg-white text-black rounded-full font-semibold">
            Reveal Message
        </button>

        <div id="output" class="p-6 bg-neutral-900 border border-neutral-800 rounded-xl text-neutral-300"></div>
    </section>

    <canvas id="canvas"></canvas>

    <script>
        /* ================= NAVIGATION ================= */
        const pages = document.querySelectorAll(".page");
        const overlay = document.querySelector(".overlay");

        function navigate() {
            const hash = location.hash.replace("#", "") || "home";
            const target = document.querySelector(`[data-page="${hash}"]`);
            if (!target) return;

            gsap.to(overlay, {
                y: "0%", duration: 0.6,
                onComplete: () => {
                    pages.forEach(p => p.classList.remove("active"));
                    target.classList.add("active");
                    gsap.from(target.children, {
                        opacity: 0, y: 40, stagger: 0.1, duration: 0.8
                    });
                    gsap.to(overlay, { y: "100%", duration: 0.6 });
                }
            });
        }
        window.addEventListener("hashchange", navigate);
        document.querySelectorAll("[data-link]").forEach(l => {
            l.onclick = e => {
                e.preventDefault();
                location.hash = l.getAttribute("href");
            };
        });
        navigate();

        /* ================= THEME ================= */
        document.getElementById("themeToggle").onclick = () => {
            document.body.classList.toggle("bg-white");
            document.body.classList.toggle("text-black");
            document.body.classList.toggle("bg-neutral-950");
            document.body.classList.toggle("text-neutral-100");
        };

        /* ================= CRYPTO ================= */
        async function getKey(password) {
            const enc = new TextEncoder();
            const keyMaterial = await crypto.subtle.importKey(
                "raw", enc.encode(password),
                { name: "PBKDF2" }, false, ["deriveKey"]
            );
            return crypto.subtle.deriveKey(
                {
                    name: "PBKDF2",
                    salt: enc.encode("obscura"),
                    iterations: 100000,
                    hash: "SHA-256"
                },
                keyMaterial,
                { name: "AES-GCM", length: 256 },
                false,
                ["encrypt", "decrypt"]
            );
        }

        async function getImageXORKey(password) {
            const hash = await crypto.subtle.digest(
                "SHA-256",
                new TextEncoder().encode(password)
            );
            return new Uint8Array(hash);
        }

        /* ================= ENCRYPT ================= */
        async function encryptAndHide() {

            const msg = document.getElementById("message").value;
            const password = document.getElementById("password").value;
            const file = document.getElementById("imageInput").files[0];
            const mode = document.getElementById("modeSelect").value;

            if (!msg || !password || !file)
                return alert("Fill all fields");

            if (file.type !== "image/png")
                return alert("Use PNG only");

            const key = await getKey(password);
            const iv = crypto.getRandomValues(new Uint8Array(12));

            const encrypted = await crypto.subtle.encrypt(
                { name: "AES-GCM", iv },
                key,
                new TextEncoder().encode(msg)
            );

            const payload = new Uint8Array([...iv, ...new Uint8Array(encrypted)]);
            const lengthBytes = new Uint8Array(4);
            new DataView(lengthBytes.buffer).setUint32(0, payload.length);
            const finalPayload = new Uint8Array([...lengthBytes, ...payload]);

            const binary = Array.from(finalPayload)
                .map(b => b.toString(2).padStart(8, "0")).join("");

            const img = new Image();
            img.src = URL.createObjectURL(file);

            img.onload = async () => {
                const canvas = document.getElementById("canvas");
                canvas.width = img.width;
                canvas.height = img.height;

                const ctx = canvas.getContext("2d");
                ctx.drawImage(img, 0, 0);

                let imageData = ctx.getImageData(0, 0, canvas.width, canvas.height);
                let data = imageData.data;

                // EMBED FIRST
                let bitIndex = 0;
                for (let i = 0; i < data.length && bitIndex < binary.length; i++) {
                    if ((i + 1) % 4 !== 0) {
                        data[i] = (data[i] & 254) | binary[bitIndex++];
                    }
                }

                // THEN SCRAMBLE
                if (mode === "visible") {
                    const xorKey = await getImageXORKey(password);
                    for (let i = 0; i < data.length; i++) {
                        if ((i + 1) % 4 !== 0) {
                            data[i] ^= xorKey[i % xorKey.length];
                        }
                    }
                }

                ctx.putImageData(imageData, 0, 0);

                const url = canvas.toDataURL("image/png");
                document.getElementById("previewImage").src = url;
                document.getElementById("downloadLink").href = url;
                document.getElementById("downloadLink").download = "secure_image.png";
                document.getElementById("previewContainer").classList.remove("hidden");
            };
        }

        /* ================= DECRYPT ================= */
        async function extractAndDecrypt() {

            const file = document.getElementById("stegoInput").files[0];
            const password = document.getElementById("decryptPassword").value;

            if (!file || !password)
                return alert("Fill all fields");

            if (file.type !== "image/png")
                return alert("Use PNG only");

            const img = new Image();
            img.src = URL.createObjectURL(file);

            img.onload = async () => {

                const canvas = document.getElementById("canvas");
                canvas.width = img.width;
                canvas.height = img.height;

                const ctx = canvas.getContext("2d");
                ctx.drawImage(img, 0, 0);

                let imageData = ctx.getImageData(0, 0, canvas.width, canvas.height);
                let data = imageData.data;

                // ALWAYS reverse scramble first
                const xorKey = await getImageXORKey(password);

                for (let i = 0; i < data.length; i++) {
                    if ((i + 1) % 4 !== 0) {
                        data[i] ^= xorKey[i % xorKey.length];
                    }
                }

                // PUT BACK RESTORED IMAGE
                ctx.putImageData(imageData, 0, 0);

                // OPTIONAL: show restored image preview
                const restoredURL = canvas.toDataURL("image/png");

                // If you want preview on decrypt page, add this:
                // document.getElementById("previewImage").src = restoredURL;

                // Now extract message
                let bits = "";
                for (let i = 0; i < data.length; i++) {
                    if ((i + 1) % 4 !== 0) {
                        bits += data[i] & 1;
                    }
                }

                let length = parseInt(bits.slice(0, 32), 2);

                if (!length || isNaN(length)) {
                    document.getElementById("output").innerText =
                        "Invalid image or wrong key.";
                    return;
                }

                let payloadBits = bits.slice(32, 32 + length * 8);
                let bytes = [];

                for (let i = 0; i < payloadBits.length; i += 8) {
                    bytes.push(parseInt(payloadBits.slice(i, i + 8), 2));
                }

                const payload = new Uint8Array(bytes);
                const iv = payload.slice(0, 12);
                const encrypted = payload.slice(12);

                try {
                    const key = await getKey(password);
                    const decrypted = await crypto.subtle.decrypt(
                        { name: "AES-GCM", iv },
                        key,
                        encrypted
                    );

                    document.getElementById("output").innerText =
                        new TextDecoder().decode(decrypted);

                } catch {
                    document.getElementById("output").innerText =
                        "Invalid key or corrupted image.";
                }
            };
        }
    </script>

</body>

</html>